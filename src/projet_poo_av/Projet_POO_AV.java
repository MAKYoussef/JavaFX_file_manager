package projet_poo_av;

// Imports nécessaires pour JavaFX, JDBC, IO, et Collections
import javafx.application.Application;
import javafx.application.Platform;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.stage.FileChooser;
import javafx.stage.Stage;

import java.awt.Desktop;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.HashSet;

// Classe principale de l'application JavaFX
public class Projet_POO_AV extends Application {

    // Configuration de la connexion à la base de données Oracle
    private static final String DB_URL = "jdbc:oracle:thin:@localhost:1521/FREEPDB1";
    private static final String DB_USER = "SYSTEM";
    private static final String DB_PASSWORD = "isg2025";

    // Éléments de l'interface utilisateur
    private Stage primaryStage;
    private TableView<FavoriteFile> tableView;
    private ObservableList<FavoriteFile> favoriteFilesData; // Liste observable pour le TableView

    // Point d'entrée principal de l'application
    public static void main(String[] args) {
        launch(args); // Lance l'application JavaFX
    }

    // Méthode principale appelée au démarrage de l'application JavaFX
    @Override
    public void start(Stage primaryStage) {
        this.primaryStage = primaryStage;
        this.primaryStage.setTitle("Projet POO AV - Gestionnaire de Fichiers");

        // Chargement du driver JDBC Oracle
        try {
            Class.forName("oracle.jdbc.driver.OracleDriver");
            System.out.println("Oracle JDBC Driver Registered!");
        } catch (ClassNotFoundException e) {
            System.err.println("CRITICAL ERREUR: Driver Oracle JDBC non trouvé.");
            System.out.println("error");
            Platform.exit();
            return;
        }

        // Initialisation des données et de la structure de la BD
        favoriteFilesData = FXCollections.observableArrayList();
        createTableIfNotExists(); // Crée la table si elle n'existe pas

        // Création de la mise en page principale
        BorderPane mainLayout = new BorderPane();
        mainLayout.setPadding(new Insets(10));

        setupTableView(); // Configuration du TableView
        mainLayout.setCenter(tableView);

        HBox buttonPanel = createButtonPanel(); // Création du panneau de boutons
        mainLayout.setBottom(buttonPanel);

        loadFavoriteFilesAndUpdateTable(); // Chargement initial des données

        // Configuration et affichage de la scène
        Scene scene = new Scene(mainLayout, 800, 600);
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    // --- Méthodes JDBC (interactions avec la base de données) ---
    // Établit une connexion à la base de données
    private Connection getConnection() throws SQLException {
        return DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
    }

    // Crée la table 'favorite_files' si elle n'existe pas
    public void createTableIfNotExists() {
        String sql = "CREATE TABLE favorite_files ("
                + "id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "
                + "file_path VARCHAR2(1000) NOT NULL UNIQUE, "
                + "title VARCHAR2(255) NOT NULL, "
                + "author VARCHAR2(255), "
                + "tags VARCHAR2(1000) NOT NULL, "
                + "summary CLOB, "
                + "comments CLOB)";
        try (Connection conn = getConnection(); Statement stmt = conn.createStatement()) {
            stmt.execute(sql);
            System.out.println("Table 'favorite_files' créée avec succès ou existe déjà.");
        } catch (SQLException e) {
            if (e.getErrorCode() == 955) { // ORA-00955: table existe déjà
                System.out.println("La table 'favorite_files' existe déjà.");
            } else {
                System.err.println("Erreur création table: " + e.getMessage() + " (Code: " + e.getErrorCode() + ")");
                showAlert(Alert.AlertType.ERROR, "DB Erreur", "Err création table:\n" + e.getMessage());
            }
        }
    }

    // Ajoute un nouveau fichier favori à la base de données
    public boolean addFavoriteFile(FavoriteFile file) {
        String sql = "INSERT INTO favorite_files (file_path, title, author, tags, summary, comments) VALUES (?, ?, ?, ?, ?, ?)";
        try (Connection conn = getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, file.getFilePath());
            pstmt.setString(2, file.getTitle());
            pstmt.setString(3, file.getAuthor());
            pstmt.setString(4, file.getTags());
            pstmt.setString(5, file.getSummary());
            pstmt.setString(6, file.getComments());
            pstmt.executeUpdate();
            showAlert(Alert.AlertType.INFORMATION, "Succès", "Fichier '" + file.getTitle() + "' ajouté.");
            return true;
        } catch (SQLException e) {
            System.err.println("Erreur ajout: " + e.getMessage() + " (Code: " + e.getErrorCode() + ")");
            if (e.getErrorCode() == 1) { // ORA-00001: contrainte unique violée
                showAlert(Alert.AlertType.ERROR, "Erreur Ajout", "Chemin '" + file.getFilePath() + "' existe déjà.");
            } else {
                showAlert(Alert.AlertType.ERROR, "Erreur Ajout", "Err ajout:\n" + e.getMessage());
            }
            return false;
        }
    }

    // Met à jour un fichier favori existant
    public boolean updateFavoriteFile(FavoriteFile file) {
        String sql = "UPDATE favorite_files SET title = ?, author = ?, tags = ?, summary = ?, comments = ? WHERE id = ?";
        try (Connection conn = getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, file.getTitle());
            pstmt.setString(2, file.getAuthor());
            pstmt.setString(3, file.getTags());
            pstmt.setString(4, file.getSummary());
            pstmt.setString(5, file.getComments());
            pstmt.setInt(6, file.getId());
            int affectedRows = pstmt.executeUpdate();
            if (affectedRows > 0) {
                showAlert(Alert.AlertType.INFORMATION, "Succès", "Fichier '" + file.getTitle() + "' mis à jour.");
                return true;
            } else {
                showAlert(Alert.AlertType.WARNING, "Mise à Jour", "Aucun fichier trouvé pour MàJ.");
                return false;
            }
        } catch (SQLException e) {
            System.err.println("Erreur MàJ: " + e.getMessage());
            showAlert(Alert.AlertType.ERROR, "Erreur MàJ", "Err MàJ:\n" + e.getMessage());
            return false;
        }
    }

    // Supprime un fichier favori par son ID
    public boolean deleteFavoriteFile(int id) {
        String sql = "DELETE FROM favorite_files WHERE id = ?";
        try (Connection conn = getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, id);
            int affectedRows = pstmt.executeUpdate();
            if (affectedRows > 0) {
                showAlert(Alert.AlertType.INFORMATION, "Succès", "Fichier supprimé.");
                return true;
            } else {
                showAlert(Alert.AlertType.WARNING, "Suppression", "Aucun fichier trouvé pour suppression.");
                return false;
            }
        } catch (SQLException e) {
            System.err.println("Erreur suppression: " + e.getMessage());
            showAlert(Alert.AlertType.ERROR, "Erreur Suppression", "Err suppression:\n" + e.getMessage());
            return false;
        }
    }

    // Récupère tous les fichiers favoris de la base de données
    public List<FavoriteFile> getAllFavoriteFiles() {
        List<FavoriteFile> files = new ArrayList<>();
        String sql = "SELECT id, file_path, title, author, tags, summary, comments FROM favorite_files ORDER BY title ASC";
        try (Connection conn = getConnection(); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(sql)) {
            while (rs.next()) {
                files.add(mapRowToFavoriteFile(rs));
            }
        } catch (SQLException e) {
            System.err.println("Erreur lecture: " + e.getMessage());
            showAlert(Alert.AlertType.ERROR, "Erreur Lecture", "Err lecture:\n" + e.getMessage());
        }
        return files;
    }

    // Recherche des fichiers favoris selon des critères spécifiques
    public List<FavoriteFile> searchFavoriteFiles(SearchCriteria criteria) {
        List<FavoriteFile> files = new ArrayList<>();
        String sqlQuery = "SELECT id, file_path, title, author, tags, summary, comments FROM favorite_files WHERE 1=1";
        List<Object> params = new ArrayList<>();

        if (!criteria.title.isEmpty()) {
            sqlQuery += " AND LOWER(title) LIKE ?";
            params.add("%" + criteria.title.toLowerCase() + "%");
        }
        if (!criteria.author.isEmpty()) {
            sqlQuery += " AND LOWER(author) LIKE ?";
            params.add("%" + criteria.author.toLowerCase() + "%");
        }
        if (!criteria.tag.isEmpty()) {
            sqlQuery += " AND LOWER(tags) LIKE ?";
            params.add("%" + criteria.tag.toLowerCase() + "%");
        }
        sqlQuery += " ORDER BY title ASC";

        try (Connection conn = getConnection(); PreparedStatement pstmt = conn.prepareStatement(sqlQuery)) {
            for (int i = 0; i < params.size(); i++) {
                pstmt.setObject(i + 1, params.get(i));
            }
            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    files.add(mapRowToFavoriteFile(rs));
                }
            }
        } catch (SQLException e) {
            System.err.println("Erreur recherche: " + e.getMessage());
            showAlert(Alert.AlertType.ERROR, "Erreur Recherche", "Err recherche:\n" + e.getMessage());
        }
        return files;
    }

    // Convertit une ligne du ResultSet en objet FavoriteFile
    private FavoriteFile mapRowToFavoriteFile(ResultSet rs) throws SQLException {
        int id = rs.getInt("id");
        String filePath = rs.getString("file_path");
        String title = rs.getString("title");
        String author = rs.getString("author");
        String tags = rs.getString("tags");
        String summary = rs.getString("summary");
        String comments = rs.getString("comments");

        FavoriteFile file = new FavoriteFile(id, filePath, title, author, tags, summary, comments);
        return file;
    }

    // --- Méthodes UI (Interface Utilisateur) ---
    // Configure le TableView et ses colonnes
    private void setupTableView() {
        tableView = new TableView<>();
        tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY_FLEX_LAST_COLUMN);

        // Définition des colonnes et de la manière dont elles obtiennent les données (setCellValueFactory)
        TableColumn<FavoriteFile, String> titleCol = new TableColumn<>("Titre");
        titleCol.setCellValueFactory(cellData -> new ReadOnlyObjectWrapper<>(cellData.getValue().getTitle()));

        TableColumn<FavoriteFile, String> authorCol = new TableColumn<>("Auteur");
        authorCol.setCellValueFactory(cellData -> new ReadOnlyObjectWrapper<>(cellData.getValue().getAuthor()));

        TableColumn<FavoriteFile, String> tagsCol = new TableColumn<>("Tags");
        tagsCol.setCellValueFactory(cellData -> new ReadOnlyObjectWrapper<>(cellData.getValue().getTags()));

        TableColumn<FavoriteFile, String> pathCol = new TableColumn<>("Chemin Fichier");
        pathCol.setCellValueFactory(cellData -> new ReadOnlyObjectWrapper<>(cellData.getValue().getFilePath()));
        pathCol.setPrefWidth(200);

        TableColumn<FavoriteFile, String> summaryCol = new TableColumn<>("Résumé");
        summaryCol.setCellValueFactory(cellData -> new ReadOnlyObjectWrapper<>(cellData.getValue().getSummary()));
        summaryCol.setPrefWidth(150);

        TableColumn<FavoriteFile, String> commentsCol = new TableColumn<>("Commentaires");
        commentsCol.setCellValueFactory(cellData -> new ReadOnlyObjectWrapper<>(cellData.getValue().getComments()));
        commentsCol.setPrefWidth(150);

        tableView.getColumns().addAll(titleCol, authorCol, tagsCol, pathCol, summaryCol, commentsCol);
        tableView.setItems(favoriteFilesData); // Lie le TableView à la liste observable

        // Ajoute un listener pour ouvrir le fichier au double-clic
        tableView.setOnMouseClicked(event -> {
            if (event.getClickCount() == 2) {
                FavoriteFile selectedFile = tableView.getSelectionModel().getSelectedItem();
                if (selectedFile != null && Desktop.isDesktopSupported()) {
                    try {
                        File fileToOpen = new File(selectedFile.getFilePath());
                        if (fileToOpen.exists()) {
                            Desktop.getDesktop().open(fileToOpen);
                        } else {
                            showAlert(Alert.AlertType.ERROR, "Erreur", "Fichier non trouvé: " + selectedFile.getFilePath());
                        }
                    } catch (IOException e) {
                        showAlert(Alert.AlertType.ERROR, "Erreur", "Impossible d'ouvrir: " + e.getMessage());
                    }
                }
            }
        });
    }

    // Crée le panneau HBox contenant les boutons d'action principaux
    private HBox createButtonPanel() {
        HBox buttonBox = new HBox(10); // Espacement de 10px entre les boutons
        buttonBox.setPadding(new Insets(10, 0, 0, 0));
        buttonBox.setAlignment(Pos.CENTER);

        // Création des boutons et assignation des actions (via lambdas)
        Button addButton = new Button("Ajouter Favori");
        addButton.setOnAction(e -> showAddEditDialog(null)); // Ouvre la boîte de dialogue d'ajout

        Button updateButton = new Button("Modifier Sélection");
        updateButton.setOnAction(e -> {
            FavoriteFile selected = tableView.getSelectionModel().getSelectedItem();
            if (selected != null) {
                showAddEditDialog(selected); // Ouvre la boîte de dialogue de modification
            } else {
                showAlert(Alert.AlertType.WARNING, "Aucune Sélection", "Veuillez sélectionner un fichier à modifier.");
            }
        });

        Button deleteButton = new Button("Supprimer Sélection");
        deleteButton.setOnAction(e -> deleteSelectedFile()); // Appelle la méthode de suppression

        Button searchButton = new Button("Rechercher");
        searchButton.setOnAction(e -> showSearchDialog()); // Ouvre la boîte de dialogue de recherche

        Button propertiesButton = new Button("Propriétés");
        propertiesButton.setOnAction(e -> showPropertiesDialog()); // Ouvre la boîte de dialogue des propriétés

        Button exportListButton = new Button("Exporter Liste");
        exportListButton.setOnAction(e -> exportToFile(false)); // Exporte la liste des fichiers

        Button exportPropsButton = new Button("Exporter Propriétés");
        exportPropsButton.setOnAction(e -> exportToFile(true)); // Exporte les propriétés

        buttonBox.getChildren().addAll(addButton, updateButton, deleteButton, searchButton, propertiesButton, exportListButton, exportPropsButton);
        return buttonBox;
    }

    // Recharge les données depuis la base et met à jour le TableView
    private void loadFavoriteFilesAndUpdateTable() {
        List<FavoriteFile> dbFiles = getAllFavoriteFiles();
        favoriteFilesData.setAll(dbFiles); // Met à jour la liste observable, ce qui rafraîchit le TableView
    }

    // Affiche la boîte de dialogue pour ajouter ou modifier un fichier favori
    private void showAddEditDialog(FavoriteFile fileToEdit) {
        Stage dialogStage = new Stage();
        dialogStage.initOwner(primaryStage);
        dialogStage.setTitle(fileToEdit == null ? "Ajouter Fichier Favori" : "Modifier Fichier Favori");

        // Création de la grille pour le formulaire
        GridPane grid = new GridPane();
        grid.setPadding(new Insets(20));
        grid.setHgap(10);
        grid.setVgap(10);
        grid.setAlignment(Pos.CENTER);

        // Création des champs du formulaire
        Label pathLabel = new Label("Fichier:");
        TextField pathField = new TextField();
        pathField.setEditable(false);
        Button chooseFileButton = new Button("Sélectionner...");
        Label titleLabel = new Label("Titre (*):");
        TextField titleField = new TextField();
        Label authorLabel = new Label("Auteur:");
        TextField authorField = new TextField();
        Label tagsLabel = new Label("Tags (*, séparés par ';'):");
        TextField tagsField = new TextField();
        Label summaryLabel = new Label("Résumé:");
        TextArea summaryArea = new TextArea();
        summaryArea.setPrefRowCount(3);
        Label commentsLabel = new Label("Commentaires:");
        TextArea commentsArea = new TextArea();
        commentsArea.setPrefRowCount(3);

        // Ajout des éléments à la grille
        grid.add(pathLabel, 0, 0);
        HBox fileBox = new HBox(5, pathField, chooseFileButton);
        HBox.setHgrow(pathField, Priority.ALWAYS);
        grid.add(fileBox, 1, 0);
        grid.add(titleLabel, 0, 1);
        grid.add(titleField, 1, 1);
        grid.add(authorLabel, 0, 2);
        grid.add(authorField, 1, 2);
        grid.add(tagsLabel, 0, 3);
        grid.add(tagsField, 1, 3);
        grid.add(summaryLabel, 0, 4);
        grid.add(summaryArea, 1, 4);
        grid.add(commentsLabel, 0, 5);
        grid.add(commentsArea, 1, 5);

        // Boutons Enregistrer et Annuler
        Button saveButton = new Button("Enregistrer");
        Button cancelButton = new Button("Annuler");
        HBox buttonBar = new HBox(10, saveButton, cancelButton);
        buttonBar.setAlignment(Pos.CENTER_RIGHT);
        grid.add(buttonBar, 1, 6);

        // Pré-remplissage des champs si on modifie un fichier existant
        if (fileToEdit != null) {
            pathField.setText(fileToEdit.getFilePath());
            titleField.setText(fileToEdit.getTitle());
            authorField.setText(fileToEdit.getAuthor());
            tagsField.setText(fileToEdit.getTags());
            summaryArea.setText(fileToEdit.getSummary());
            commentsArea.setText(fileToEdit.getComments());
            chooseFileButton.setDisable(true); // On ne peut pas changer le fichier lors de la modification
        }

        // Action du bouton pour choisir un fichier
        chooseFileButton.setOnAction(e -> {
            FileChooser fc = new FileChooser();
            fc.setTitle("Sélectionner un fichier");
            File sf = fc.showOpenDialog(dialogStage);
            if (sf != null) {
                pathField.setText(sf.getAbsolutePath());
                if (titleField.getText() == null || titleField.getText().trim().isEmpty()) {
                    titleField.setText(sf.getName());
                }
            }
        });

        // Action du bouton Enregistrer
        saveButton.setOnAction(e -> {
            String fp = pathField.getText(), t = titleField.getText(), a = authorField.getText(), tg = tagsField.getText(), s = summaryArea.getText(), c = commentsArea.getText();
            // Validation des champs obligatoires
            if (fp == null || fp.trim().isEmpty()) {
                showAlert(Alert.AlertType.ERROR, "Erreur", "Veuillez sélectionner un fichier.");
                return;
            }
            if (t == null || t.trim().isEmpty()) {
                showAlert(Alert.AlertType.ERROR, "Erreur", "Le champ 'Titre' est obligatoire.");
                return;
            }
            if (tg == null || tg.trim().isEmpty()) {
                showAlert(Alert.AlertType.ERROR, "Erreur", "Le champ 'Tags' est obligatoire.");
                return;
            }

            // Création de l'objet FavoriteFile
            FavoriteFile file = new FavoriteFile((fileToEdit != null) ? fileToEdit.getId() : 0, fp.trim(), t.trim(), a.trim(), tg.trim(), s.trim(), c.trim());
            boolean success = (fileToEdit == null) ? addFavoriteFile(file) : updateFavoriteFile(file); // Ajout ou mise à jour
            if (success) {
                loadFavoriteFilesAndUpdateTable(); // Recharge les données
                dialogStage.close(); // Ferme la boîte de dialogue
            }
        });

        // Action du bouton Annuler
        cancelButton.setOnAction(e -> dialogStage.close());

        // Affichage de la boîte de dialogue
        Scene dialogScene = new Scene(grid, 500, 400);
        dialogStage.setScene(dialogScene);
        dialogStage.showAndWait(); // Attend que la boîte de dialogue soit fermée
    }

    // Supprime le fichier sélectionné dans le TableView
    private void deleteSelectedFile() {
        FavoriteFile selected = tableView.getSelectionModel().getSelectedItem();
        if (selected == null) {
            showAlert(Alert.AlertType.WARNING, "Aucune Sélection", "Veuillez sélectionner un fichier.");
            return;
        }

        // Demande de confirmation
        Alert confirm = new Alert(Alert.AlertType.CONFIRMATION);
        confirm.setTitle("Confirmation de Suppression");
        confirm.setHeaderText(null);
        confirm.setContentText("Supprimer le favori '" + selected.getTitle() + "'?");
        Optional<ButtonType> res = confirm.showAndWait();

        if (res.isPresent() && res.get() == ButtonType.OK) {
            if (deleteFavoriteFile(selected.getId())) { // Appel de la méthode JDBC
                loadFavoriteFilesAndUpdateTable(); // Recharge les données
            }
        }
    }

    // Affiche la boîte de dialogue de recherche (utilise maintenant une Stage standard)
    private void showSearchDialog() {
        Stage dialogStage = new Stage();
        dialogStage.initOwner(primaryStage);
        dialogStage.setTitle("Rechercher des Fichiers Favoris");

        GridPane grid = new GridPane();
        grid.setHgap(10);
        grid.setVgap(10);
        grid.setPadding(new Insets(20, 20, 10, 20));

        TextField tfT = new TextField();
        tfT.setPromptText("Titre contient...");
        TextField tfA = new TextField();
        tfA.setPromptText("Auteur contient...");
        TextField tfTag = new TextField();
        tfTag.setPromptText("Tag contient...");

        grid.add(new Label("Titre:"), 0, 0);
        grid.add(tfT, 1, 0);
        grid.add(new Label("Auteur:"), 0, 1);
        grid.add(tfA, 1, 1);
        grid.add(new Label("Tag:"), 0, 2);
        grid.add(tfTag, 1, 2);

        Button searchButton = new Button("Rechercher");
        Button cancelButton = new Button("Annuler");

        HBox buttonBar = new HBox(10, searchButton, cancelButton);
        buttonBar.setAlignment(Pos.CENTER_RIGHT);
        grid.add(buttonBar, 1, 3);

        // Action pour le bouton Rechercher
        searchButton.setOnAction(e -> {
            SearchCriteria criteria = new SearchCriteria(tfT.getText(), tfA.getText(), tfTag.getText());
            List<FavoriteFile> searchResults = searchFavoriteFiles(criteria);
            favoriteFilesData.setAll(searchResults); // Met à jour la liste principale avec les résultats
            if (searchResults.isEmpty()) {
                showAlert(Alert.AlertType.INFORMATION, "Recherche", "Aucun fichier trouvé pour ces critères.");
            } else {
                showAlert(Alert.AlertType.INFORMATION, "Recherche", searchResults.size() + " fichier(s) trouvé(s).");
            }
            dialogStage.close();
        });

        cancelButton.setOnAction(e -> dialogStage.close());

        Platform.runLater(tfT::requestFocus);

        Scene dialogScene = new Scene(grid);
        dialogStage.setScene(dialogScene);
        dialogStage.showAndWait();
    }

    // Classe interne pour aider au tri des tags par nombre d'occurrences
    private static class TagCount implements Comparable<TagCount> {

        String tag;
        int count;

        public TagCount(String tag, int count) {
            this.tag = tag;
            this.count = count;
        }

        // Tri par compte (décroissant) puis par nom (croissant)
        @Override
        public int compareTo(TagCount other) {
            if (this.count != other.count) {
                return Integer.compare(other.count, this.count);
            }
            return this.tag.compareTo(other.tag);
        }
    }

    // Affiche la boîte de dialogue des propriétés (nombre total, auteurs, tags, etc.)
    private void showPropertiesDialog() {
        Stage dialogStage = new Stage();
        dialogStage.initOwner(primaryStage);
        dialogStage.setTitle("Propriétés des Fichiers Favoris");
        TextArea propertiesArea = new TextArea();
        propertiesArea.setEditable(false);
        propertiesArea.setWrapText(true);
        List<FavoriteFile> allFiles = getAllFavoriteFiles();

        // Construction du texte des propriétés (sans StringBuilder)
        String propsText = "";
        propsText += "Nombre total de fichiers favoris: " + allFiles.size() + "\n\n";

        // Calcul et ajout des auteurs uniques
        HashSet<String> uniqueAuthorsSet = new HashSet<>();
        for (FavoriteFile f : allFiles) {
            if (f.getAuthor() != null && !f.getAuthor().isEmpty()) {
                uniqueAuthorsSet.add(f.getAuthor());
            }
        }
        List<String> sortedAuthors = new ArrayList<>(uniqueAuthorsSet);
        Collections.sort(sortedAuthors);
        propsText += "Liste des Auteurs:\n";
        if (sortedAuthors.isEmpty()) {
            propsText += "  (Aucun auteur spécifié)\n";
        } else {
            for (String a : sortedAuthors) {
                propsText += "  - " + a + "\n";
            }
        }
        propsText += "\n";

        // Calcul et ajout des tags uniques
        HashSet<String> uniqueTagsSet = new HashSet<>();
        List<String> allTagsForCounting = new ArrayList<>();
        for (FavoriteFile f : allFiles) {
            if (f.getTags() != null && !f.getTags().isEmpty()) {
                String[] ta = f.getTags().split("\\s*;\\s*");
                for (String t : ta) {
                    String tr = t.trim();
                    if (!tr.isEmpty()) {
                        uniqueTagsSet.add(tr);
                        allTagsForCounting.add(tr);
                    }
                }
            }
        }
        List<String> sortedUniqueTags = new ArrayList<>(uniqueTagsSet);
        Collections.sort(sortedUniqueTags);
        propsText += "Liste des Tags Uniques (Centres d'intérêt):\n";
        if (sortedUniqueTags.isEmpty()) {
            propsText += "  (Aucun tag utilisé)\n";
        } else {
            for (String t : sortedUniqueTags) {
                propsText += "  - " + t + "\n";
            }
        }
        propsText += "\n";

        // Calcul et ajout du nombre de fichiers par tag
        List<TagCount> tagCountsList = new ArrayList<>();
        for (String ut : sortedUniqueTags) {
            int c = 0;
            for (String at : allTagsForCounting) {
                if (ut.equals(at)) {
                    c++;
                }
            }
            tagCountsList.add(new TagCount(ut, c));
        }
        Collections.sort(tagCountsList);
        propsText += "Nombre de fichiers par Tag:\n";
        if (tagCountsList.isEmpty()) {
            propsText += "  (Aucun tag utilisé)\n";
        } else {
            for (TagCount tc : tagCountsList) {
                propsText += "  - " + tc.tag + ": " + tc.count + "\n";
            }
        }

        propertiesArea.setText(propsText);
        VBox layout = new VBox(10, propertiesArea);
        layout.setPadding(new Insets(10));
        VBox.setVgrow(propertiesArea, Priority.ALWAYS);
        Scene dialogScene = new Scene(layout, 450, 400);
        dialogStage.setScene(dialogScene);
        dialogStage.showAndWait();
    }

    // Exporte la liste des favoris ou les propriétés dans un fichier texte
    private void exportToFile(boolean exportProperties) {
        FileChooser fc = new FileChooser();
        fc.setTitle("Exporter vers Fichier Texte");
        fc.getExtensionFilters().add(new FileChooser.ExtensionFilter("Fichiers Texte (*.txt)", "*.txt"));
        File file = fc.showSaveDialog(primaryStage);
        if (file != null) {
            if (!file.getName().toLowerCase().endsWith(".txt")) {
                file = new File(file.getAbsolutePath() + ".txt");
            }
            try (PrintWriter writer = new PrintWriter(new FileWriter(file))) {
                if (exportProperties) {
                    // Exportation des propriétés (logique similaire à showPropertiesDialog)
                    List<FavoriteFile> allFiles = getAllFavoriteFiles();
                    String propsText = "";
                    propsText += "Propriétés des Fichiers Favoris\n=================================\n\n";
                    propsText += "Nombre total de fichiers favoris: " + allFiles.size() + "\n\n";
                    HashSet<String> uniqueAuthorsSet = new HashSet<>();
                    for (FavoriteFile f : allFiles) {
                        if (f.getAuthor() != null && !f.getAuthor().isEmpty()) {
                            uniqueAuthorsSet.add(f.getAuthor());
                        }
                    }
                    List<String> sortedAuthors = new ArrayList<>(uniqueAuthorsSet);
                    Collections.sort(sortedAuthors);
                    propsText += "Liste des Auteurs:\n";
                    if (sortedAuthors.isEmpty()) {
                        propsText += "  (Aucun auteur spécifié)\n";
                    } else {
                        for (String a : sortedAuthors) {
                            propsText += "  - " + a + "\n";
                        }
                    }
                    propsText += "\n";
                    HashSet<String> uniqueTagsSet = new HashSet<>();
                    List<String> allTagsList = new ArrayList<>();
                    for (FavoriteFile f : allFiles) {
                        if (f.getTags() != null && !f.getTags().isEmpty()) {
                            String[] ta = f.getTags().split("\\s*;\\s*");
                            for (String t : ta) {
                                String tr = t.trim();
                                if (!tr.isEmpty()) {
                                    uniqueTagsSet.add(tr);
                                    allTagsList.add(tr);
                                }
                            }
                        }
                    }
                    List<String> sortedUniqueTags = new ArrayList<>(uniqueTagsSet);
                    Collections.sort(sortedUniqueTags);
                    propsText += "Liste des Tags Uniques:\n";
                    if (sortedUniqueTags.isEmpty()) {
                        propsText += "  (Aucun tag utilisé)\n";
                    } else {
                        for (String t : sortedUniqueTags) {
                            propsText += "  - " + t + "\n";
                        }
                    }
                    propsText += "\n";
                    List<TagCount> tagCountsList = new ArrayList<>();
                    for (String ut : sortedUniqueTags) {
                        int c = 0;
                        for (String at : allTagsList) {
                            if (ut.equals(at)) {
                                c++;
                            }
                        }
                        tagCountsList.add(new TagCount(ut, c));
                    }
                    Collections.sort(tagCountsList);
                    propsText += "Nombre de fichiers par Tag:\n";
                    if (tagCountsList.isEmpty()) {
                        propsText += "  (Aucun tag utilisé)\n";
                    } else {
                        for (TagCount tc : tagCountsList) {
                            propsText += "  - " + tc.tag + ": " + tc.count + "\n";
                        }
                    }
                    writer.print(propsText);
                    showAlert(Alert.AlertType.INFORMATION, "Exportation Réussie", "Propriétés exportées.");
                } else {
                    // Exportation de la liste des fichiers actuellement affichés
                    writer.println("Liste des Fichiers Favoris\n==========================");
                    List<FavoriteFile> filesToExport = new ArrayList<>(this.favoriteFilesData); // Copie de la liste actuelle
                    if (filesToExport.isEmpty()) {
                        writer.println("\n(Aucun fichier favori à exporter)");
                    } else {
                        for (FavoriteFile ff : filesToExport) {
                            writer.println("------------------------------");
                            writer.println("Titre: " + ff.getTitle());
                            writer.println("Auteur: " + (ff.getAuthor().isEmpty() ? "(non spécifié)" : ff.getAuthor()));
                            writer.println("Tags: " + ff.getTags());
                            writer.println("Chemin: " + ff.getFilePath());
                            writer.println("Résumé: " + (ff.getSummary().isEmpty() ? "(aucun)" : ff.getSummary()));
                            writer.println("Commentaires: " + (ff.getComments().isEmpty() ? "(aucun)" : ff.getComments()));
                        }
                    }
                    showAlert(Alert.AlertType.INFORMATION, "Exportation Réussie", "Liste des favoris exportée.");
                }
            } catch (IOException ex) {
                showAlert(Alert.AlertType.ERROR, "Erreur Exportation", "Impossible d'écrire:\n" + ex.getMessage());
            }
        }
    }

    // Affiche une boîte de dialogue (Alert) ou un message d'erreur simple sur la console
    private void showAlert(Alert.AlertType type, String title, String content) {
        if (type == Alert.AlertType.INFORMATION || type == Alert.AlertType.CONFIRMATION) {
            Alert alert = new Alert(type);
            alert.setTitle(title);
            alert.setHeaderText(null);
            alert.setContentText(content);
            alert.showAndWait();
        } else { // Pour ERROR ou WARNING
            System.out.println("error: [" + type + "] " + title + " - " + content.replace("\n", " "));
        }
    }

    // Classe interne représentant un fichier favori (POJO)
    public static class FavoriteFile {

        private final int id;
        private final String filePath;
        private final String title;
        private final String author;
        private final String tags;
        private final String summary;
        private final String comments;

        public FavoriteFile(int id, String filePath, String title, String author, String tags, String summary, String comments) {
            this.id = id;
            this.filePath = filePath;
            this.title = title;
            if (author == null) {
                this.author = "";
            } else {
                this.author = author;
            }
            this.tags = tags;
            if (summary == null) {
                this.summary = "";
            } else {
                this.summary = summary;
            }
            if (comments == null) {
                this.comments = "";
            } else {
                this.comments = comments;
            }
        }

        // Getters pour accéder aux champs
        public int getId() {
            return id;
        }

        public String getFilePath() {
            return filePath;
        }

        public String getTitle() {
            return title;
        }

        public String getAuthor() {
            return author;
        }

        public String getTags() {
            return tags;
        }

        public String getSummary() {
            return summary;
        }

        public String getComments() {
            return comments;
        }
    }

    // Classe interne représentant les critères de recherche
    private static class SearchCriteria {

        final String title;
        final String author;
        final String tag;

        SearchCriteria(String title, String author, String tag) {
            // Utilisation de if-else pour la simplification demandée
            if (title == null) {
                this.title = "";
            } else {
                this.title = title.trim();
            }
            if (author == null) {
                this.author = "";
            } else {
                this.author = author.trim();
            }
            if (tag == null) {
                this.tag = "";
            } else {
                this.tag = tag.trim();
            }
        }
    }
}
